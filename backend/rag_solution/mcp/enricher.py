"""Search Result Enricher using MCP tools.

This module implements the Content Enricher pattern (Gregor Hohpe, Enterprise Integration Patterns)
for enhancing search results with artifacts generated by MCP tools.

Key Design Principles:
    - Enrichment is OPTIONAL: Tool failures never block core RAG flow
    - Enrichment is PARALLEL: Multiple tools run concurrently for performance
    - Enrichment is ASYNCHRONOUS: Non-blocking relative to answer generation
    - Error ISOLATION: Each tool invocation is isolated, failures don't cascade

Usage:
    enricher = SearchResultEnricher(mcp_client, settings)
    enriched = await enricher.enrich_results(
        search_output=search_result,
        tool_hints=["powerpoint", "visualization"]
    )
"""

import asyncio
from dataclasses import dataclass, field
from typing import Any, ClassVar
from uuid import UUID

from core.config import Settings
from core.logging_utils import get_logger

from .gateway_client import MCPGatewayClient, MCPToolResult

logger = get_logger(__name__)


@dataclass
class EnrichmentArtifact:
    """An artifact generated by MCP tool enrichment.

    Attributes:
        tool_name: Name of the tool that generated this artifact
        artifact_type: Type of artifact (e.g., "powerpoint", "chart", "visualization")
        content: Artifact content (may be base64 encoded for binary formats)
        content_type: MIME type of the content
        metadata: Additional metadata about the artifact
    """

    tool_name: str
    artifact_type: str
    content: str | bytes
    content_type: str
    metadata: dict[str, Any] = field(default_factory=dict)


@dataclass
class EnrichmentResult:
    """Result of search result enrichment.

    Attributes:
        original_answer: The original answer from RAG
        artifacts: List of generated artifacts
        enrichment_metadata: Metadata about the enrichment process
        errors: List of any errors during enrichment (for debugging)
    """

    original_answer: str
    artifacts: list[EnrichmentArtifact] = field(default_factory=list)
    enrichment_metadata: dict[str, Any] = field(default_factory=dict)
    errors: list[str] = field(default_factory=list)


class SearchResultEnricher:
    """Enriches search results with MCP tool-generated artifacts.

    Follows the Content Enricher pattern with these guarantees:
    - Never blocks or fails the core RAG search flow
    - Tool invocations run in parallel for performance
    - Each tool failure is isolated and logged
    - Returns original results unchanged if enrichment fails entirely

    Typical use case: Generate a PowerPoint presentation from search results.
    """

    # Supported tool mappings with their artifact types
    SUPPORTED_TOOLS: ClassVar[dict[str, str]] = {
        "powerpoint": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "visualization": "image/svg+xml",
        "chart": "image/png",
        "pdf_export": "application/pdf",
    }

    def __init__(
        self,
        mcp_client: MCPGatewayClient,
        settings: Settings,
        max_concurrent_tools: int = 3,
        enrichment_timeout: float = 60.0,
    ) -> None:
        """Initialize the enricher.

        Args:
            mcp_client: MCP Gateway client for tool invocation
            settings: Application settings
            max_concurrent_tools: Maximum tools to run concurrently
            enrichment_timeout: Overall timeout for enrichment process
        """
        self.mcp_client = mcp_client
        self.settings = settings
        self.max_concurrent_tools = max_concurrent_tools
        self.enrichment_timeout = enrichment_timeout

    async def enrich_results(
        self,
        answer: str,
        documents: list[dict[str, Any]],
        query: str,
        collection_id: UUID,
        tool_hints: list[str] | None = None,
        user_id: UUID | None = None,
    ) -> EnrichmentResult:
        """Enrich search results with MCP tool-generated artifacts.

        Args:
            answer: The generated RAG answer
            documents: Source documents used for the answer
            query: Original user query
            collection_id: Collection ID for context
            tool_hints: Optional list of specific tools to use
            user_id: Optional user ID for tracking

        Returns:
            EnrichmentResult with original answer and any generated artifacts
        """
        result = EnrichmentResult(original_answer=answer)

        # If no tools specified, return original results
        if not tool_hints:
            logger.debug("No tool hints provided, skipping enrichment")
            return result

        # Filter to supported tools only
        requested_tools = [t for t in tool_hints if t in self.SUPPORTED_TOOLS]

        if not requested_tools:
            logger.debug(
                "No supported tools in hints: %s",
                tool_hints,
                extra={"supported_tools": list(self.SUPPORTED_TOOLS.keys())},
            )
            return result

        logger.info(
            "Starting search result enrichment",
            extra={
                "tools": requested_tools,
                "query": query[:100],
                "collection_id": str(collection_id),
                "user_id": str(user_id) if user_id else None,
            },
        )

        try:
            # Run enrichment with timeout
            artifacts, errors = await asyncio.wait_for(
                self._run_enrichment(
                    answer=answer,
                    documents=documents,
                    query=query,
                    tools=requested_tools,
                ),
                timeout=self.enrichment_timeout,
            )

            result.artifacts = artifacts
            result.errors = errors
            result.enrichment_metadata = {
                "tools_requested": requested_tools,
                "tools_successful": [a.tool_name for a in artifacts],
                "tools_failed": len(errors),
            }

            logger.info(
                "Enrichment completed",
                extra={
                    "artifacts_generated": len(artifacts),
                    "errors": len(errors),
                },
            )

        except TimeoutError:
            error_msg = f"Enrichment timed out after {self.enrichment_timeout}s"
            logger.warning(error_msg)
            result.errors.append(error_msg)
            result.enrichment_metadata["timeout"] = True

        except Exception as e:
            # Catch-all to ensure enrichment never crashes the main flow
            error_msg = f"Enrichment failed: {e!s}"
            logger.error(error_msg, exc_info=True)
            result.errors.append(error_msg)

        return result

    async def _run_enrichment(
        self,
        answer: str,
        documents: list[dict[str, Any]],
        query: str,
        tools: list[str],
    ) -> tuple[list[EnrichmentArtifact], list[str]]:
        """Run enrichment tools in parallel with concurrency limit.

        Args:
            answer: RAG answer
            documents: Source documents
            query: User query
            tools: Tools to invoke

        Returns:
            Tuple of (artifacts, errors)
        """
        semaphore = asyncio.Semaphore(self.max_concurrent_tools)
        artifacts: list[EnrichmentArtifact] = []
        errors: list[str] = []

        async def invoke_with_limit(tool_name: str) -> MCPToolResult:
            async with semaphore:
                return await self._invoke_tool(tool_name, answer, documents, query)

        # Run all tools in parallel with semaphore limiting
        tasks = [invoke_with_limit(tool) for tool in tools]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        for tool_name, result in zip(tools, results, strict=False):
            if isinstance(result, Exception):
                error_msg = f"Tool '{tool_name}' raised exception: {result!s}"
                logger.error(error_msg)
                errors.append(error_msg)
                continue

            if not result.success:
                error_msg = f"Tool '{tool_name}' failed: {result.error}"
                logger.warning(error_msg)
                errors.append(error_msg)
                continue

            # Extract artifact from result
            artifact = self._extract_artifact(tool_name, result)
            if artifact:
                artifacts.append(artifact)

        return artifacts, errors

    async def _invoke_tool(
        self,
        tool_name: str,
        answer: str,
        documents: list[dict[str, Any]],
        query: str,
    ) -> MCPToolResult:
        """Invoke a specific enrichment tool.

        Args:
            tool_name: Name of the tool
            answer: RAG answer
            documents: Source documents
            query: User query

        Returns:
            MCPToolResult from the invocation
        """
        # Build tool-specific arguments
        arguments = self._build_tool_arguments(tool_name, answer, documents, query)

        return await self.mcp_client.invoke_tool(tool_name, arguments)

    def _build_tool_arguments(
        self,
        tool_name: str,
        answer: str,
        documents: list[dict[str, Any]],
        query: str,
    ) -> dict[str, Any]:
        """Build arguments for a specific tool.

        Args:
            tool_name: Name of the tool
            answer: RAG answer
            documents: Source documents
            query: User query

        Returns:
            Tool-specific argument dictionary
        """
        # Common context passed to all tools
        base_context = {
            "query": query,
            "answer": answer,
            "sources": [
                {
                    "title": doc.get("title", doc.get("document_name", "Unknown")),
                    "content": doc.get("content", doc.get("text", "")),
                    "metadata": {k: v for k, v in doc.items() if k not in ("content", "text")},
                }
                for doc in documents[:10]  # Limit to 10 docs for context size
            ],
        }

        # Tool-specific argument structures
        if tool_name == "powerpoint":
            return {
                "title": query[:100],  # Use query as title
                "content": answer,
                "sources": base_context["sources"],
                "style": "professional",
            }

        if tool_name == "visualization":
            return {
                "data": base_context,
                "chart_type": "auto",  # Let tool decide
            }

        if tool_name == "chart":
            return {
                "context": base_context,
                "chart_type": "bar",  # Default to bar chart
            }

        if tool_name == "pdf_export":
            return {
                "title": query[:100],
                "content": answer,
                "sources": base_context["sources"],
            }

        # Generic fallback
        return base_context

    def _extract_artifact(
        self,
        tool_name: str,
        result: MCPToolResult,
    ) -> EnrichmentArtifact | None:
        """Extract artifact from tool result.

        Args:
            tool_name: Name of the tool
            result: Tool invocation result

        Returns:
            EnrichmentArtifact if content found, None otherwise
        """
        if not result.result:
            return None

        # Handle different result formats
        data = result.result

        # Look for content in common fields
        content = data.get("content") or data.get("data") or data.get("output")
        if not content:
            logger.debug("No content found in tool result for %s", tool_name)
            return None

        content_type = self.SUPPORTED_TOOLS.get(tool_name, "application/octet-stream")

        return EnrichmentArtifact(
            tool_name=tool_name,
            artifact_type=tool_name,
            content=content,
            content_type=content_type,
            metadata={
                "duration_ms": result.duration_ms,
                "tool_metadata": data.get("metadata", {}),
            },
        )

    async def get_available_tools(self) -> list[str]:
        """Get list of available enrichment tools from gateway.

        Returns:
            List of tool names that are both available and supported
        """
        try:
            all_tools = await self.mcp_client.list_tools()
            tool_names = {t.get("name") for t in all_tools if t.get("name")}

            # Return intersection of available and supported
            available = [t for t in self.SUPPORTED_TOOLS if t in tool_names]

            logger.debug(
                "Available enrichment tools: %s",
                available,
                extra={"gateway_tools": len(all_tools)},
            )

            return available

        except Exception as e:
            logger.warning("Failed to get available tools: %s", str(e))
            return []
