# =============================================================================
# Workflow: Deploy Complete RAG Modulo Application
# =============================================================================
# Description: Comprehensive deployment workflow for RAG Modulo application
#              including infrastructure, backend, and frontend components
#              to IBM Cloud Code Engine with security scanning and testing.
#
# Author: RAG Modulo Team
# Last Updated: 2025-01-13
# Version: 2.0
#
# Triggers:
#   - Manual dispatch (workflow_dispatch)
#   - Daily builds (schedule: 2 AM UTC)
#   - Push to main/develop branches
#
# Prerequisites:
#   - IBM Cloud API Key configured as secret
#   - IBM Cloud Container Registry namespace created
#   - All application secrets configured in repository settings
#
# Jobs:
#   1. deploy-infrastructure: Deploy PostgreSQL, MinIO, etcd, Milvus
#   2. build-and-push-backend: Build and push backend Docker image
#   3. build-and-push-frontend: Build and push frontend Docker image
#   4. security-scan-*: Scan images for vulnerabilities with Trivy
#   5. deploy-*: Deploy applications to IBM Cloud Code Engine
#   6. smoke-test: Verify deployment health and functionality
#
# Security Features:
#   - Trivy vulnerability scanning with SARIF output
#   - Non-root container execution
#   - Command injection prevention
#   - Secret management via GitHub Secrets
#
# Resources Deployed:
#   - Backend: 1 CPU, 4GB RAM, scales 1-5 instances
#   - Frontend: 0.5 CPU, 1GB RAM, scales 1-3 instances
#   - PostgreSQL: 0.5 CPU, 2GB RAM
#   - MinIO: 0.25 CPU, 1GB RAM
#   - etcd: 0.25 CPU, 1GB RAM
#   - Milvus: 0.5 CPU, 2GB RAM
# =============================================================================

name: Deploy Complete RAG Modulo Application

# Define workflow triggers
on:
  # Manual deployment with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "dev"
        type: choice
        options:
          - dev
          - staging
          - production
      skip_security_scan:
        description: "Skip security scanning (not recommended)"
        required: false
        default: false
        type: boolean
      deploy_after_build:
        description: "Deploy after building (for daily builds)"
        required: false
        default: false
        type: boolean
  # Daily automated builds at 2 AM UTC
  schedule:
    - cron: "0 2 * * *"
  # Automatic deployment on code changes
  push:
    branches:
      - main
    tags:
      - "v*.*.*"  # Semantic version tags (e.g., v1.0.0, v1.2.3)
  # Release workflow - triggered when a version tag is pushed
  release:
    types: [published]

# Define environment variables for the entire workflow
env:
  PROJECT_NAME: rag-modulo-${{ inputs.environment || 'dev' }}
  BACKEND_APP_NAME: ${{ vars.BACKEND_APP_NAME || 'rag-modulo-backend' }}
  FRONTEND_APP_NAME: ${{ vars.FRONTEND_APP_NAME || 'rag-modulo-frontend' }}
  IBM_CLOUD_REGION: ${{ vars.IBM_CLOUD_REGION || 'us-south' }}
  CR_NAMESPACE: ${{ vars.IBM_CR_NAMESPACE || 'rag_modulo' }}
  # ICR uses shortened region names: us-south -> us, eu-gb -> uk, ca-tor -> ca, etc.
  ICR_REGION: ${{ vars.IBM_CLOUD_REGION == 'eu-gb' && 'uk' || (vars.IBM_CLOUD_REGION == 'us-south' && 'us' ||
    (vars.IBM_CLOUD_REGION == 'us-east' && 'us' || (vars.IBM_CLOUD_REGION == 'ca-tor' && 'ca' ||
    vars.IBM_CLOUD_REGION))) }}
  # Version tagging strategy (priority order):
  # 1. Git tag (v1.0.0) -> use tag name
  # 2. GitHub variable PROJECT_VERSION -> use that
  # 3. Read from .env file (PROJECT_VERSION=0.8.0) -> matches Makefile behavior
  # 4. Read from Makefile default (PROJECT_VERSION ?= 1.0.0)
  # 5. Fallback to commit SHA for development builds
  # Note: PROJECT_VERSION will be extracted from .env or Makefile in a job step
  IS_RELEASE: ${{ startsWith(github.ref, 'refs/tags/v') }}
  # Image retention: Keep last N images per repository (default: 30)
  IMAGE_RETENTION_COUNT: ${{ vars.IMAGE_RETENTION_COUNT || '30' }}

# Prevent concurrent deployments to avoid conflicts
concurrency:
  group: deploy-complete-app-${{ github.ref }}
  cancel-in-progress: false

# =============================================================================
# WORKFLOW JOBS
# =============================================================================
jobs:
  # ---------------------------------------------------------------------------
  # Job 1: Deploy Infrastructure Components
  # ---------------------------------------------------------------------------
  # Purpose: Deploy core infrastructure services (PostgreSQL, MinIO, etcd, Milvus)
  # Dependencies: None (runs first)
  # Outputs: Infrastructure services ready for application deployment
  # ---------------------------------------------------------------------------
  deploy-infrastructure:
    runs-on: ubuntu-latest
    outputs:
      project_name: ${{ steps.setup-project.outputs.project_name }}
    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Ansible and dependencies
        run: |
          pip install ansible
          ansible-galaxy collection install -r deployment/ansible/requirements.yml

      - name: Set up IBM Cloud CLI
        uses: IBM/actions-ibmcloud-cli@v1
        with:
          api_key: ${{ secrets.IBM_CLOUD_API_KEY }}
          region: ${{ env.IBM_CLOUD_REGION }}
          group: ${{ vars.IBM_CLOUD_RESOURCE_GROUP || 'rag-modulo-deployment' }}
          plugins: code-engine

      - name: Deploy Infrastructure using Ansible
        id: setup-project
        env:
          IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
          IBM_CLOUD_REGION: ${{ env.IBM_CLOUD_REGION }}
          IBM_CLOUD_RESOURCE_GROUP: ${{ vars.IBM_CLOUD_RESOURCE_GROUP || 'rag-modulo-deployment' }}
          COLLECTIONDB_USER: ${{ secrets.COLLECTIONDB_USER }}
          COLLECTIONDB_PASS: ${{ secrets.COLLECTIONDB_PASS }}
          COLLECTIONDB_NAME: ${{ secrets.COLLECTIONDB_NAME }}
          MINIO_ROOT_USER: ${{ secrets.MINIO_ROOT_USER || 'minioadmin' }}
          MINIO_ROOT_PASSWORD: ${{ secrets.MINIO_ROOT_PASSWORD || 'minioadmin' }}
        run: |
          # Create temporary inventory for infrastructure deployment
          cat > /tmp/inventory.yml << EOF
          all:
            hosts:
              localhost:
                ansible_connection: local
                ansible_python_interpreter: "{{ ansible_playbook_python }}"
            vars:
              project_name: "rag-modulo"
              environment: "dev"
              region: "${{ env.IBM_CLOUD_REGION }}"
              resource_group_id: "${{ vars.IBM_CLOUD_RESOURCE_GROUP || 'rag-modulo-deployment' }}"
              ibmcloud_api_key: "${{ secrets.IBM_CLOUD_API_KEY }}"
          EOF

          # Note: Full Ansible deployment will be implemented in next iteration
          # For now, we'll use IBM Cloud CLI directly for infrastructure
          echo "Deploying infrastructure components..."
          ibmcloud login --apikey "$IBM_CLOUD_API_KEY" --no-region
          ibmcloud target -r "$IBM_CLOUD_REGION" -g "$IBM_CLOUD_RESOURCE_GROUP"

          # Create Code Engine project if it doesn't exist (idempotent)
          # Check if project exists and handle soft-deleted state
          if ibmcloud ce project get --name "$PROJECT_NAME" 2>&1 | grep -q "soft deleted"; then
            echo "‚ö†Ô∏è  Project '$PROJECT_NAME' is soft-deleted, creating new one with timestamp..."
            NEW_PROJECT_NAME="${PROJECT_NAME}-$(date +%s)"
            echo "üÜï Creating project '$NEW_PROJECT_NAME'..."
            ibmcloud ce project create --name "$NEW_PROJECT_NAME"
            ibmcloud ce project select --name "$NEW_PROJECT_NAME"
            echo "PROJECT_NAME=$NEW_PROJECT_NAME" >> $GITHUB_ENV
            echo "project_name=$NEW_PROJECT_NAME" >> $GITHUB_OUTPUT
          elif ibmcloud ce project get --name "$PROJECT_NAME" &>/dev/null; then
            echo "‚úÖ Project '$PROJECT_NAME' exists - selecting..."
            ibmcloud ce project select --name "$PROJECT_NAME"
            echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          else
            echo "üÜï Creating project '$PROJECT_NAME'..."
            ibmcloud ce project create --name "$PROJECT_NAME"
            ibmcloud ce project select --name "$PROJECT_NAME"
            echo "project_name=$PROJECT_NAME" >> $GITHUB_OUTPUT
          fi

          echo "Infrastructure deployment placeholder - will be enhanced with full Ansible playbook"

  # ---------------------------------------------------------------------------
  # Job 2: Build and Push Backend Application
  # ---------------------------------------------------------------------------
  # Purpose: Build Docker image for backend FastAPI application and push to registry
  # Dependencies: deploy-infrastructure (must complete first)
  # Outputs: Backend Docker image in IBM Cloud Container Registry
  # Security: Multi-stage build, non-root user, CPU-only PyTorch
  # ---------------------------------------------------------------------------
  build-and-push-backend:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write
      security-events: write
    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Extract PROJECT_VERSION from .env or Makefile
        id: get-version
        run: |
          # Priority order:
          # 1. Git tag (v1.0.0) -> use tag name
          # 2. GitHub variable PROJECT_VERSION
          # 3. Read from .env file (PROJECT_VERSION=0.8.0) - matches Makefile behavior
          # 4. Read from Makefile default (PROJECT_VERSION ?= 1.0.0)
          # 5. Read from pyproject.toml (version = "1.0.0")
          # 6. Fallback to commit SHA
          
          if [[ "${{ github.ref }}" =~ ^refs/tags/v ]]; then
            # Use git tag (remove 'v' prefix if present)
            VERSION="${{ github.ref_name }}"
            echo "Using git tag version: $VERSION"
          elif [ -n "${{ vars.PROJECT_VERSION }}" ]; then
            # Use GitHub variable
            VERSION="${{ vars.PROJECT_VERSION }}"
            echo "Using GitHub variable PROJECT_VERSION: $VERSION"
          elif [ -f .env ]; then
            # Read from .env file (same as Makefile does)
            VERSION=$(grep -E '^PROJECT_VERSION\s*=' .env | sed -E 's/^PROJECT_VERSION\s*=\s*//' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using .env PROJECT_VERSION: $VERSION"
            fi
          fi
          
          # Fallback to Makefile default if still empty
          if [ -z "$VERSION" ] && [ -f Makefile ]; then
            VERSION=$(grep -E '^PROJECT_VERSION\s*\?=\s*' Makefile | sed -E 's/^PROJECT_VERSION\s*\?=\s*//' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using Makefile default PROJECT_VERSION: $VERSION"
            fi
          fi
          
          # Fallback to pyproject.toml if still empty
          if [ -z "$VERSION" ] && [ -f pyproject.toml ]; then
            VERSION=$(grep -E '^version\s*=\s*' pyproject.toml | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using pyproject.toml version: $VERSION"
            fi
          fi
          
          # Final fallback to commit SHA
          if [ -z "$VERSION" ]; then
            VERSION="${{ github.sha }}"
            echo "Using commit SHA as version: $VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "‚úÖ Determined version: $VERSION"

      - name: Free up disk space
        run: |
          echo "Initial disk space: $(df -h / | awk 'NR==2 {print $4}') available"
          
          # Remove unnecessary packages to free up space
          # GitHub runners have ~14GB available, but pre-installed tools use ~70GB
          sudo rm -rf /usr/share/dotnet &
          sudo rm -rf /opt/ghc &
          sudo rm -rf /usr/local/share/boost &
          sudo rm -rf "$AGENT_TOOLSDIRECTORY" &
          sudo rm -rf /usr/local/lib/android &
          sudo rm -rf /usr/share/swift &
          wait
          
          # Clean Docker to free up space
          docker system prune -af --volumes || true
          
          echo "After cleanup: $(df -h / | awk 'NR==2 {print $4}') available"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to IBM Cloud Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ICR_REGION }}.icr.io
          username: iamapikey
          password: ${{ secrets.IBM_CLOUD_API_KEY }}

      - name: Build and push backend Docker image
        id: build-backend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.codeengine
          platforms: linux/amd64
          push: true
          # Versioning strategy:
          # - Always tag with commit SHA (immutable, traceable)
          # - Tag with PROJECT_VERSION from Makefile/.env (if not a git tag)
          # - Tag with semantic version if this is a release (v1.0.0, etc.)
          # - Tag with 'latest' for convenience (NOT for production deployments)
          tags: |
            ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.BACKEND_APP_NAME }}:${{ github.sha }}
            ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.BACKEND_APP_NAME }}:${{ steps.get-version.outputs.version }}
            ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.BACKEND_APP_NAME }}:latest
          # Use minimal cache to reduce disk usage
          cache-from: type=gha
          cache-to: type=gha,mode=min
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          # Don't load image locally, push directly to save space
          load: false

      - name: Verify backend image was pushed to ICR
        env:
          ICR_REGION: ${{ env.ICR_REGION }}
          CR_NAMESPACE: ${{ env.CR_NAMESPACE }}
          BACKEND_APP_NAME: ${{ env.BACKEND_APP_NAME }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -e
          IMAGE_URL="$ICR_REGION.icr.io/$CR_NAMESPACE/$BACKEND_APP_NAME:$IMAGE_TAG"
          echo "Verifying image exists in ICR: $IMAGE_URL"
          
          # Login to ICR to verify image
          echo "${{ secrets.IBM_CLOUD_API_KEY }}" | docker login -u iamapikey --password-stdin "$ICR_REGION.icr.io" || { echo "‚ùå Failed to login to ICR"; exit 1; }
          
          # Try to pull the image manifest to verify it exists
          if docker manifest inspect "$IMAGE_URL" > /dev/null 2>&1; then
            echo "‚úÖ Image verified in ICR: $IMAGE_URL"
          else
            echo "‚ùå Image not found in ICR: $IMAGE_URL"
            echo "This usually means the build/push step failed silently."
            exit 1
          fi

      - name: Clean up Docker build cache (Backend)
        if: always()
        run: |
          echo "Cleaning up Docker build cache..."
          # Remove all stopped containers
          docker container prune -f || true
          # Remove all unused images (not just dangling)
          docker image prune -af || true
          # Remove build cache
          docker builder prune -af || true
          # Full system prune
          docker system prune -af --volumes || true
          echo "Final disk space: $(df -h / | awk 'NR==2 {print $4}') available"

  build-and-push-frontend:
    needs: deploy-infrastructure
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read
      packages: write
      security-events: write
    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Extract PROJECT_VERSION from .env or Makefile
        id: get-version
        run: |
          # Priority order:
          # 1. Git tag (v1.0.0) -> use tag name
          # 2. GitHub variable PROJECT_VERSION
          # 3. Read from .env file (PROJECT_VERSION=0.8.0) - matches Makefile behavior
          # 4. Read from Makefile default (PROJECT_VERSION ?= 1.0.0)
          # 5. Read from pyproject.toml (version = "1.0.0")
          # 6. Fallback to commit SHA
          
          if [[ "${{ github.ref }}" =~ ^refs/tags/v ]]; then
            # Use git tag (remove 'v' prefix if present)
            VERSION="${{ github.ref_name }}"
            echo "Using git tag version: $VERSION"
          elif [ -n "${{ vars.PROJECT_VERSION }}" ]; then
            # Use GitHub variable
            VERSION="${{ vars.PROJECT_VERSION }}"
            echo "Using GitHub variable PROJECT_VERSION: $VERSION"
          elif [ -f .env ]; then
            # Read from .env file (same as Makefile does)
            VERSION=$(grep -E '^PROJECT_VERSION\s*=' .env | sed -E 's/^PROJECT_VERSION\s*=\s*//' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using .env PROJECT_VERSION: $VERSION"
            fi
          fi
          
          # Fallback to Makefile default if still empty
          if [ -z "$VERSION" ] && [ -f Makefile ]; then
            VERSION=$(grep -E '^PROJECT_VERSION\s*\?=\s*' Makefile | sed -E 's/^PROJECT_VERSION\s*\?=\s*//' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using Makefile default PROJECT_VERSION: $VERSION"
            fi
          fi
          
          # Fallback to pyproject.toml if still empty
          if [ -z "$VERSION" ] && [ -f pyproject.toml ]; then
            VERSION=$(grep -E '^version\s*=\s*' pyproject.toml | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using pyproject.toml version: $VERSION"
            fi
          fi
          
          # Final fallback to commit SHA
          if [ -z "$VERSION" ]; then
            VERSION="${{ github.sha }}"
            echo "Using commit SHA as version: $VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "‚úÖ Determined version: $VERSION"

      - name: Free up disk space
        run: |
          echo "Initial disk space: $(df -h / | awk 'NR==2 {print $4}') available"
          
          # Remove unnecessary packages to free up space
          sudo rm -rf /usr/share/dotnet &
          sudo rm -rf /opt/ghc &
          sudo rm -rf /usr/local/share/boost &
          sudo rm -rf "$AGENT_TOOLSDIRECTORY" &
          sudo rm -rf /usr/local/lib/android &
          sudo rm -rf /usr/share/swift &
          wait
          
          # Clean Docker to free up space
          docker system prune -af --volumes || true
          
          echo "After cleanup: $(df -h / | awk 'NR==2 {print $4}') available"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to IBM Cloud Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ICR_REGION }}.icr.io
          username: iamapikey
          password: ${{ secrets.IBM_CLOUD_API_KEY }}

      - name: Build and push frontend Docker image
        id: build-frontend
        uses: docker/build-push-action@v6
        with:
          context: ./frontend
          file: ./frontend/Dockerfile.frontend
          platforms: linux/amd64
          push: true
          # Versioning strategy:
          # - Always tag with commit SHA (immutable, traceable)
          # - Tag with PROJECT_VERSION from Makefile/.env (if not a git tag)
          # - Tag with semantic version if this is a release (v1.0.0, etc.)
          # - Tag with 'latest' for convenience (NOT for production deployments)
          tags: |
            ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.FRONTEND_APP_NAME }}:${{ github.sha }}
            ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.FRONTEND_APP_NAME }}:${{ steps.get-version.outputs.version }}
            ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.FRONTEND_APP_NAME }}:latest
          # Use minimal cache to reduce disk usage
          cache-from: type=gha
          cache-to: type=gha,mode=min
          build-args: |
            BUILDKIT_INLINE_CACHE=1
          # Don't load image locally, push directly to save space
          load: false

      - name: Verify frontend image was pushed to ICR
        env:
          ICR_REGION: ${{ env.ICR_REGION }}
          CR_NAMESPACE: ${{ env.CR_NAMESPACE }}
          FRONTEND_APP_NAME: ${{ env.FRONTEND_APP_NAME }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -e
          IMAGE_URL="$ICR_REGION.icr.io/$CR_NAMESPACE/$FRONTEND_APP_NAME:$IMAGE_TAG"
          echo "Verifying image exists in ICR: $IMAGE_URL"
          
          # Login to ICR to verify image
          echo "${{ secrets.IBM_CLOUD_API_KEY }}" | docker login -u iamapikey --password-stdin "$ICR_REGION.icr.io" || { echo "‚ùå Failed to login to ICR"; exit 1; }
          
          # Try to pull the image manifest to verify it exists
          if docker manifest inspect "$IMAGE_URL" > /dev/null 2>&1; then
            echo "‚úÖ Image verified in ICR: $IMAGE_URL"
          else
            echo "‚ùå Image not found in ICR: $IMAGE_URL"
            echo "This usually means the build/push step failed silently."
            exit 1
          fi

      - name: Clean up Docker build cache (Frontend)
        if: always()
        run: |
          echo "Cleaning up Docker build cache..."
          # Remove all stopped containers
          docker container prune -f || true
          # Remove all unused images (not just dangling)
          docker image prune -af || true
          # Remove build cache
          docker builder prune -af || true
          # Full system prune
          docker system prune -af --volumes || true
          echo "Final disk space: $(df -h / | awk 'NR==2 {print $4}') available"

  security-scan-backend:
    needs: build-and-push-backend
    if: ${{ !inputs.skip_security_scan }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Log in to IBM Cloud Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ICR_REGION }}.icr.io
          username: iamapikey
          password: ${{ secrets.IBM_CLOUD_API_KEY }}

      - name: Pull Docker image for scanning
        run: |
          echo "Pulling image: ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.BACKEND_APP_NAME }}:${{ github.sha }}"
          docker pull ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.BACKEND_APP_NAME }}:${{ github.sha }} || { echo "‚ùå Failed to pull image"; exit 1; }
          echo "‚úÖ Image pulled successfully"
          docker images | grep "${{ env.BACKEND_APP_NAME }}" || { echo "‚ùå Image not found in local registry"; exit 1; }

      - name: Run Trivy vulnerability scanner (Backend)
        continue-on-error: true
        uses: aquasecurity/trivy-action@master
        env:
          TRIVY_USERNAME: iamapikey
          TRIVY_PASSWORD: ${{ secrets.IBM_CLOUD_API_KEY }}
          TRIVY_REGISTRY_USERNAME: iamapikey
          TRIVY_REGISTRY_PASSWORD: ${{ secrets.IBM_CLOUD_API_KEY }}
        with:
          image-ref: ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.BACKEND_APP_NAME }}:${{ github.sha }}
          format: "sarif"
          output: "trivy-backend-results.sarif"
          exit-code: "0" # Don't fail on vulnerabilities, just report them

      - name: Upload Trivy scan results to GitHub Security tab (Backend)
        continue-on-error: true
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles('trivy-backend-results.sarif') != ''
        with:
          sarif_file: "trivy-backend-results.sarif"

      - name: Run Trivy vulnerability scanner (Backend - Table)
        uses: aquasecurity/trivy-action@master
        env:
          TRIVY_USERNAME: iamapikey
          TRIVY_PASSWORD: ${{ secrets.IBM_CLOUD_API_KEY }}
          TRIVY_REGISTRY_USERNAME: iamapikey
          TRIVY_REGISTRY_PASSWORD: ${{ secrets.IBM_CLOUD_API_KEY }}
        with:
          image-ref: ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.BACKEND_APP_NAME }}:${{ github.sha }}
          format: "table"
          exit-code: "0" # Changed to 0 to not block deployment, but severity filter still applies
          severity: "CRITICAL,HIGH"

      - name: Clean up pulled image
        if: always()
        run: |
          docker rmi ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.BACKEND_APP_NAME }}:${{ github.sha }} || true

  security-scan-frontend:
    needs: build-and-push-frontend
    if: ${{ !inputs.skip_security_scan }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Log in to IBM Cloud Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.ICR_REGION }}.icr.io
          username: iamapikey
          password: ${{ secrets.IBM_CLOUD_API_KEY }}

      - name: Pull Docker image for scanning
        run: |
          echo "Pulling image: ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.FRONTEND_APP_NAME }}:${{ github.sha }}"
          docker pull ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.FRONTEND_APP_NAME }}:${{ github.sha }} || { echo "‚ùå Failed to pull image"; exit 1; }
          echo "‚úÖ Image pulled successfully"
          docker images | grep "${{ env.FRONTEND_APP_NAME }}" || { echo "‚ùå Image not found in local registry"; exit 1; }

      - name: Run Trivy vulnerability scanner (Frontend)
        continue-on-error: true
        uses: aquasecurity/trivy-action@master
        env:
          TRIVY_USERNAME: iamapikey
          TRIVY_PASSWORD: ${{ secrets.IBM_CLOUD_API_KEY }}
          TRIVY_REGISTRY_USERNAME: iamapikey
          TRIVY_REGISTRY_PASSWORD: ${{ secrets.IBM_CLOUD_API_KEY }}
        with:
          image-ref: ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.FRONTEND_APP_NAME }}:${{ github.sha }}
          format: "sarif"
          output: "trivy-frontend-results.sarif"
          exit-code: "0" # Don't fail on vulnerabilities, just report them

      - name: Upload Trivy scan results to GitHub Security tab (Frontend)
        continue-on-error: true
        uses: github/codeql-action/upload-sarif@v4
        if: always() && hashFiles('trivy-frontend-results.sarif') != ''
        with:
          sarif_file: "trivy-frontend-results.sarif"

      - name: Run Trivy vulnerability scanner (Frontend - Table)
        uses: aquasecurity/trivy-action@master
        env:
          TRIVY_USERNAME: iamapikey
          TRIVY_PASSWORD: ${{ secrets.IBM_CLOUD_API_KEY }}
          TRIVY_REGISTRY_USERNAME: iamapikey
          TRIVY_REGISTRY_PASSWORD: ${{ secrets.IBM_CLOUD_API_KEY }}
        with:
          image-ref: ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.FRONTEND_APP_NAME }}:${{ github.sha }}
          format: "table"
          exit-code: "0" # Changed to 0 to not block deployment, but severity filter still applies
          severity: "CRITICAL,HIGH"

      - name: Clean up pulled image
        if: always()
        run: |
          docker rmi ${{ env.ICR_REGION }}.icr.io/${{ env.CR_NAMESPACE }}/${{ env.FRONTEND_APP_NAME }}:${{ github.sha }} || true

  deploy-backend:
    needs: [deploy-infrastructure, build-and-push-backend, security-scan-backend]
    if: always() && needs.build-and-push-backend.result == 'success' && (needs.security-scan-backend.result == 'success' || needs.security-scan-backend.result == 'skipped')
      && (github.event_name == 'workflow_dispatch' || github.event_name == 'push' || (github.event_name == 'schedule' &&
      inputs.deploy_after_build == true))
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up IBM Cloud CLI
        uses: IBM/actions-ibmcloud-cli@v1
        with:
          api_key: ${{ secrets.IBM_CLOUD_API_KEY }}
          region: ${{ env.IBM_CLOUD_REGION }}
          group: ${{ vars.IBM_CLOUD_RESOURCE_GROUP || 'rag-modulo-deployment' }}
          plugins: code-engine

      - name: Extract PROJECT_VERSION (same as build job)
        id: get-version
        run: |
          # Priority order (same as build job):
          # 1. Git tag (v1.0.0) -> use tag name
          # 2. GitHub variable PROJECT_VERSION
          # 3. Read from .env file (PROJECT_VERSION=0.8.0)
          # 4. Read from Makefile default (PROJECT_VERSION ?= 1.0.0)
          # 5. Read from pyproject.toml (version = "1.0.0")
          # 6. Fallback to commit SHA
          
          if [[ "${{ github.ref }}" =~ ^refs/tags/v ]]; then
            VERSION="${{ github.ref_name }}"
            echo "Using git tag version: $VERSION"
          elif [ -n "${{ vars.PROJECT_VERSION }}" ]; then
            VERSION="${{ vars.PROJECT_VERSION }}"
            echo "Using GitHub variable PROJECT_VERSION: $VERSION"
          elif [ -f .env ]; then
            VERSION=$(grep -E '^PROJECT_VERSION\s*=' .env | sed -E 's/^PROJECT_VERSION\s*=\s*//' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using .env PROJECT_VERSION: $VERSION"
            fi
          fi
          
          if [ -z "$VERSION" ] && [ -f Makefile ]; then
            VERSION=$(grep -E '^PROJECT_VERSION\s*\?=\s*' Makefile | sed -E 's/^PROJECT_VERSION\s*\?=\s*//' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using Makefile default PROJECT_VERSION: $VERSION"
            fi
          fi
          
          if [ -z "$VERSION" ] && [ -f pyproject.toml ]; then
            VERSION=$(grep -E '^version\s*=\s*' pyproject.toml | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using pyproject.toml version: $VERSION"
            fi
          fi
          
          if [ -z "$VERSION" ]; then
            VERSION="${{ github.sha }}"
            echo "Using commit SHA as version: $VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "‚úÖ Determined version: $VERSION"

      - name: Verify backend image exists before deployment
        env:
          ICR_REGION: ${{ env.ICR_REGION }}
          CR_NAMESPACE: ${{ env.CR_NAMESPACE }}
          BACKEND_APP_NAME: ${{ env.BACKEND_APP_NAME }}
        run: |
          set -e
          VERSION="${{ steps.get-version.outputs.version }}"
          COMMIT_SHA="${{ github.sha }}"
          
          # Login to ICR
          echo "${{ secrets.IBM_CLOUD_API_KEY }}" | docker login -u iamapikey --password-stdin "$ICR_REGION.icr.io" || { echo "‚ùå Failed to login to ICR"; exit 1; }
          
          # Try multiple image tags in priority order
          IMAGE_FOUND=false
          IMAGE_URL=""
          
          # Priority 1: Try commit SHA (most specific)
          if docker manifest inspect "$ICR_REGION.icr.io/$CR_NAMESPACE/$BACKEND_APP_NAME:$COMMIT_SHA" > /dev/null 2>&1; then
            IMAGE_URL="$ICR_REGION.icr.io/$CR_NAMESPACE/$BACKEND_APP_NAME:$COMMIT_SHA"
            IMAGE_FOUND=true
            echo "‚úÖ Found image with commit SHA tag: $IMAGE_URL"
          # Priority 2: Try version tag (if different from commit SHA)
          elif [ "$VERSION" != "$COMMIT_SHA" ] && docker manifest inspect "$ICR_REGION.icr.io/$CR_NAMESPACE/$BACKEND_APP_NAME:$VERSION" > /dev/null 2>&1; then
            IMAGE_URL="$ICR_REGION.icr.io/$CR_NAMESPACE/$BACKEND_APP_NAME:$VERSION"
            IMAGE_FOUND=true
            echo "‚úÖ Found image with version tag: $IMAGE_URL"
          # Priority 3: Try latest (fallback)
          elif docker manifest inspect "$ICR_REGION.icr.io/$CR_NAMESPACE/$BACKEND_APP_NAME:latest" > /dev/null 2>&1; then
            IMAGE_URL="$ICR_REGION.icr.io/$CR_NAMESPACE/$BACKEND_APP_NAME:latest"
            IMAGE_FOUND=true
            echo "‚ö†Ô∏è  Using 'latest' tag (commit SHA and version tags not found): $IMAGE_URL"
          fi
          
          if [ "$IMAGE_FOUND" = false ]; then
            echo "‚ùå No image found in ICR with any of these tags:"
            echo "  - $COMMIT_SHA (commit SHA)"
            echo "  - $VERSION (version)"
            echo "  - latest"
            echo ""
            echo "Cannot deploy - no image exists. Check build job logs."
            exit 1
          fi
          
          # Export IMAGE_URL for use in deployment step
          echo "IMAGE_URL=$IMAGE_URL" >> $GITHUB_ENV
          echo "‚úÖ Image confirmed in ICR: $IMAGE_URL"

      - name: Deploy Backend to Code Engine
        env:
          IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
          ICR_REGION: ${{ env.ICR_REGION }}
          # IMAGE_URL is set by the verification step above
          APP_NAME: ${{ env.BACKEND_APP_NAME }}
          PROJECT_NAME: ${{ needs.deploy-infrastructure.outputs.project_name || env.PROJECT_NAME }}
          IBM_CLOUD_REGION: ${{ env.IBM_CLOUD_REGION }}
          IBM_CLOUD_RESOURCE_GROUP: ${{ vars.IBM_CLOUD_RESOURCE_GROUP || 'rag-modulo-deployment' }}
          SKIP_AUTH: ${{ secrets.SKIP_AUTH }}
          OIDC_DISCOVERY_ENDPOINT: ${{ secrets.OIDC_DISCOVERY_ENDPOINT }}
          IBM_CLIENT_ID: ${{ secrets.IBM_CLIENT_ID }}
          IBM_CLIENT_SECRET: ${{ secrets.IBM_CLIENT_SECRET }}
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
          WATSONX_APIKEY: ${{ secrets.WATSONX_APIKEY }}
          WATSONX_INSTANCE_ID: ${{ secrets.WATSONX_INSTANCE_ID }}
          COLLECTIONDB_USER: ${{ secrets.COLLECTIONDB_USER }}
          COLLECTIONDB_PASS: ${{ secrets.COLLECTIONDB_PASS }}
          COLLECTIONDB_HOST: rag-modulo-postgres
          COLLECTIONDB_PORT: "5432"
          COLLECTIONDB_NAME: ${{ secrets.COLLECTIONDB_NAME }}
          VECTOR_DB: "milvus"
          MILVUS_HOST: rag-modulo-milvus
          MILVUS_PORT: "19530"
          MILVUS_USER: ""
          MILVUS_PASSWORD: ""
          MINIO_ENDPOINT: rag-modulo-minio:9000
          MINIO_ACCESS_KEY: ${{ secrets.MINIO_ROOT_USER || 'minioadmin' }}
          MINIO_SECRET_KEY: ${{ secrets.MINIO_ROOT_PASSWORD || 'minioadmin' }}
          MINIO_USE_SSL: "false"
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          LOG_LEVEL: "INFO"
        run: |
          set -e  # Exit on error
          echo "Deploying backend application..."
          ibmcloud login --apikey "$IBM_CLOUD_API_KEY" --no-region || { echo "‚ùå Failed to login to IBM Cloud"; exit 1; }
          ibmcloud target -r "$IBM_CLOUD_REGION" -g "$IBM_CLOUD_RESOURCE_GROUP" || { echo "‚ùå Failed to set target"; exit 1; }

          # Ensure project exists and handle soft-deleted state
          # Check if project is soft-deleted BEFORE trying to select it
          PROJECT_STATUS=$(ibmcloud ce project get --name "$PROJECT_NAME" 2>&1 || echo "")
          
          if echo "$PROJECT_STATUS" | grep -q "soft deleted"; then
            echo "‚ö†Ô∏è  Project '$PROJECT_NAME' is soft-deleted, creating new one with timestamp..."
            NEW_PROJECT_NAME="${PROJECT_NAME}-$(date +%s)"
            echo "üÜï Creating project '$NEW_PROJECT_NAME'..."
            ibmcloud ce project create --name "$NEW_PROJECT_NAME" || { echo "‚ùå Failed to create project"; exit 1; }
            ibmcloud ce project select --name "$NEW_PROJECT_NAME" || { echo "‚ùå Failed to select new project"; exit 1; }
            PROJECT_NAME="$NEW_PROJECT_NAME"
            echo "‚úÖ Using new project: $PROJECT_NAME"
          elif ibmcloud ce project get --name "$PROJECT_NAME" &>/dev/null; then
            echo "‚úÖ Project '$PROJECT_NAME' exists - selecting..."
            ibmcloud ce project select --name "$PROJECT_NAME" || { echo "‚ùå Failed to select project"; exit 1; }
          else
            echo "üÜï Creating project '$PROJECT_NAME'..."
            ibmcloud ce project create --name "$PROJECT_NAME" || { echo "‚ùå Failed to create project"; exit 1; }
            ibmcloud ce project select --name "$PROJECT_NAME" || { echo "‚ùå Failed to select project"; exit 1; }
          fi

          # Create or update registry access secret
          echo "Setting up registry access..."
          if ibmcloud ce secret get --name icr-secret > /dev/null 2>&1; then
            echo "Registry secret already exists"
          else
            echo "Creating registry access secret..."
            ibmcloud ce secret create --name icr-secret \
              --format registry \
              --server ${ICR_REGION}.icr.io \
              --username iamapikey \
              --password "$IBM_CLOUD_API_KEY"
          fi

          # Deploy or update backend application (idempotent)
          # Try to update first - if app doesn't exist, update will fail and we'll create
          echo "Checking if backend application exists..."
          set +e  # Temporarily disable exit on error to check update result
          UPDATE_OUTPUT=$(ibmcloud ce app update --name "$APP_NAME" \
              --image "$IMAGE_URL" \
              --registry-secret icr-secret \
              --min-scale 1 \
              --max-scale 5 \
              --cpu 1 \
              --memory 4G \
              --env DATABASE_URL="postgresql://$COLLECTIONDB_USER:$COLLECTIONDB_PASS@$COLLECTIONDB_HOST:$COLLECTIONDB_PORT/$COLLECTIONDB_NAME?sslmode=require" \
              --env MILVUS_HOST="$MILVUS_HOST" \
              --env MILVUS_PORT="$MILVUS_PORT" \
              --env MINIO_ENDPOINT="$MINIO_ENDPOINT" \
              --env MINIO_ACCESS_KEY="$MINIO_ACCESS_KEY" \
              --env MINIO_SECRET_KEY="$MINIO_SECRET_KEY" \
              --env WATSONX_APIKEY="$WATSONX_APIKEY" \
              --env WATSONX_INSTANCE_ID="$WATSONX_INSTANCE_ID" \
              --env JWT_SECRET_KEY="$JWT_SECRET_KEY" \
              --env LOG_LEVEL="$LOG_LEVEL" \
              --env SKIP_AUTH="$SKIP_AUTH" 2>&1)
          UPDATE_EXIT=$?
          set -e  # Re-enable exit on error
          
          if [ $UPDATE_EXIT -ne 0 ] && echo "$UPDATE_OUTPUT" | grep -qE "not found|does not exist|No.*found"; then
            echo "App not found, creating new backend application..."
            ibmcloud ce app create --name "$APP_NAME" \
              --image "$IMAGE_URL" \
              --registry-secret icr-secret \
              --min-scale 1 \
              --max-scale 5 \
              --cpu 1 \
              --memory 4G \
              --port 8000 \
              --env DATABASE_URL="postgresql://$COLLECTIONDB_USER:$COLLECTIONDB_PASS@$COLLECTIONDB_HOST:$COLLECTIONDB_PORT/$COLLECTIONDB_NAME?sslmode=require" \
              --env MILVUS_HOST="$MILVUS_HOST" \
              --env MILVUS_PORT="$MILVUS_PORT" \
              --env MINIO_ENDPOINT="$MINIO_ENDPOINT" \
              --env MINIO_ACCESS_KEY="$MINIO_ACCESS_KEY" \
              --env MINIO_SECRET_KEY="$MINIO_SECRET_KEY" \
              --env WATSONX_APIKEY="$WATSONX_APIKEY" \
              --env WATSONX_INSTANCE_ID="$WATSONX_INSTANCE_ID" \
              --env JWT_SECRET_KEY="$JWT_SECRET_KEY" \
              --env LOG_LEVEL="$LOG_LEVEL" \
              --env SKIP_AUTH="$SKIP_AUTH" || { echo "‚ùå Failed to create app"; exit 1; }
            echo "‚úÖ Backend application created successfully"
          else
            if [ $UPDATE_EXIT -eq 0 ]; then
              echo "‚úÖ Backend application updated successfully"
            else
              echo "‚ùå Failed to update backend application"
              echo "Update output: $UPDATE_OUTPUT"
              exit 1
            fi
          fi
          
          # Verify deployment and show revision info
          echo "Verifying backend deployment..."
          sleep 5  # Give Code Engine a moment to create the revision
          APP_STATUS=$(ibmcloud ce app get --name "$APP_NAME" --output json 2>/dev/null || echo "{}")
          LATEST_REVISION=$(echo "$APP_STATUS" | jq -r '.status.latestCreatedRevisionName // empty')
          if [ -n "$LATEST_REVISION" ] && [ "$LATEST_REVISION" != "null" ]; then
            echo "‚úÖ New revision created: $LATEST_REVISION"
            echo "Image: $IMAGE_URL"
            REVISION_STATUS=$(ibmcloud ce revision get --name "$LATEST_REVISION" --output json 2>/dev/null | jq -r '.status.conditions[]? | select(.type == "Ready") | "Status: \(.status), Reason: \(.reason // "N/A"), Message: \(.message // "N/A")"' || echo "Could not get revision status")
            echo "$REVISION_STATUS"
          else
            echo "‚ö†Ô∏è  Could not determine latest revision - deployment may still be in progress"
          fi

          echo "Backend deployment complete!"

  deploy-frontend:
    needs: [deploy-infrastructure, build-and-push-frontend, security-scan-frontend]
    if: always() && needs.build-and-push-frontend.result == 'success' && (needs.security-scan-frontend.result == 'success' || needs.security-scan-frontend.result ==
      'skipped') && (github.event_name == 'workflow_dispatch' || github.event_name == 'push' || (github.event_name ==
      'schedule' && inputs.deploy_after_build == true))
    runs-on: ubuntu-latest
    timeout-minutes: 15
    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up IBM Cloud CLI
        uses: IBM/actions-ibmcloud-cli@v1
        with:
          api_key: ${{ secrets.IBM_CLOUD_API_KEY }}
          region: ${{ env.IBM_CLOUD_REGION }}
          group: ${{ vars.IBM_CLOUD_RESOURCE_GROUP || 'rag-modulo-deployment' }}
          plugins: code-engine

      - name: Extract PROJECT_VERSION (same as build job)
        id: get-version
        run: |
          # Priority order (same as build job):
          # 1. Git tag (v1.0.0) -> use tag name
          # 2. GitHub variable PROJECT_VERSION
          # 3. Read from .env file (PROJECT_VERSION=0.8.0)
          # 4. Read from Makefile default (PROJECT_VERSION ?= 1.0.0)
          # 5. Read from pyproject.toml (version = "1.0.0")
          # 6. Fallback to commit SHA
          
          if [[ "${{ github.ref }}" =~ ^refs/tags/v ]]; then
            VERSION="${{ github.ref_name }}"
            echo "Using git tag version: $VERSION"
          elif [ -n "${{ vars.PROJECT_VERSION }}" ]; then
            VERSION="${{ vars.PROJECT_VERSION }}"
            echo "Using GitHub variable PROJECT_VERSION: $VERSION"
          elif [ -f .env ]; then
            VERSION=$(grep -E '^PROJECT_VERSION\s*=' .env | sed -E 's/^PROJECT_VERSION\s*=\s*//' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using .env PROJECT_VERSION: $VERSION"
            fi
          fi
          
          if [ -z "$VERSION" ] && [ -f Makefile ]; then
            VERSION=$(grep -E '^PROJECT_VERSION\s*\?=\s*' Makefile | sed -E 's/^PROJECT_VERSION\s*\?=\s*//' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using Makefile default PROJECT_VERSION: $VERSION"
            fi
          fi
          
          if [ -z "$VERSION" ] && [ -f pyproject.toml ]; then
            VERSION=$(grep -E '^version\s*=\s*' pyproject.toml | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/' | tr -d ' ' || echo "")
            if [ -n "$VERSION" ]; then
              echo "Using pyproject.toml version: $VERSION"
            fi
          fi
          
          if [ -z "$VERSION" ]; then
            VERSION="${{ github.sha }}"
            echo "Using commit SHA as version: $VERSION"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "‚úÖ Determined version: $VERSION"

      - name: Verify frontend image exists before deployment
        env:
          ICR_REGION: ${{ env.ICR_REGION }}
          CR_NAMESPACE: ${{ env.CR_NAMESPACE }}
          FRONTEND_APP_NAME: ${{ env.FRONTEND_APP_NAME }}
        run: |
          set -e
          VERSION="${{ steps.get-version.outputs.version }}"
          COMMIT_SHA="${{ github.sha }}"
          
          # Login to ICR
          echo "${{ secrets.IBM_CLOUD_API_KEY }}" | docker login -u iamapikey --password-stdin "$ICR_REGION.icr.io" || { echo "‚ùå Failed to login to ICR"; exit 1; }
          
          # Try multiple image tags in priority order
          IMAGE_FOUND=false
          IMAGE_URL=""
          
          # Priority 1: Try commit SHA (most specific)
          if docker manifest inspect "$ICR_REGION.icr.io/$CR_NAMESPACE/$FRONTEND_APP_NAME:$COMMIT_SHA" > /dev/null 2>&1; then
            IMAGE_URL="$ICR_REGION.icr.io/$CR_NAMESPACE/$FRONTEND_APP_NAME:$COMMIT_SHA"
            IMAGE_FOUND=true
            echo "‚úÖ Found image with commit SHA tag: $IMAGE_URL"
          # Priority 2: Try version tag (if different from commit SHA)
          elif [ "$VERSION" != "$COMMIT_SHA" ] && docker manifest inspect "$ICR_REGION.icr.io/$CR_NAMESPACE/$FRONTEND_APP_NAME:$VERSION" > /dev/null 2>&1; then
            IMAGE_URL="$ICR_REGION.icr.io/$CR_NAMESPACE/$FRONTEND_APP_NAME:$VERSION"
            IMAGE_FOUND=true
            echo "‚úÖ Found image with version tag: $IMAGE_URL"
          # Priority 3: Try latest (fallback)
          elif docker manifest inspect "$ICR_REGION.icr.io/$CR_NAMESPACE/$FRONTEND_APP_NAME:latest" > /dev/null 2>&1; then
            IMAGE_URL="$ICR_REGION.icr.io/$CR_NAMESPACE/$FRONTEND_APP_NAME:latest"
            IMAGE_FOUND=true
            echo "‚ö†Ô∏è  Using 'latest' tag (commit SHA and version tags not found): $IMAGE_URL"
          fi
          
          if [ "$IMAGE_FOUND" = false ]; then
            echo "‚ùå No image found in ICR with any of these tags:"
            echo "  - $COMMIT_SHA (commit SHA)"
            echo "  - $VERSION (version)"
            echo "  - latest"
            echo ""
            echo "Cannot deploy - no image exists. Check build job logs."
            exit 1
          fi
          
          # Export IMAGE_URL for use in deployment step
          echo "IMAGE_URL=$IMAGE_URL" >> $GITHUB_ENV
          echo "‚úÖ Image confirmed in ICR: $IMAGE_URL"

      - name: Deploy Frontend to Code Engine
        env:
          IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
          ICR_REGION: ${{ env.ICR_REGION }}
          # IMAGE_URL is set by the verification step above
          APP_NAME: ${{ env.FRONTEND_APP_NAME }}
          PROJECT_NAME: ${{ needs.deploy-infrastructure.outputs.project_name || env.PROJECT_NAME }}
          IBM_CLOUD_REGION: ${{ env.IBM_CLOUD_REGION }}
          IBM_CLOUD_RESOURCE_GROUP: ${{ vars.IBM_CLOUD_RESOURCE_GROUP || 'rag-modulo-deployment' }}
          REACT_APP_API_URL: ${{ secrets.REACT_APP_API_URL }}
          REACT_APP_WS_URL: ${{ secrets.REACT_APP_WS_URL }}
          BACKEND_APP_NAME: ${{ env.BACKEND_APP_NAME }}
        run: |
          set -e  # Exit on error
          echo "Deploying frontend application..."
          ibmcloud login --apikey "$IBM_CLOUD_API_KEY" --no-region || { echo "‚ùå Failed to login to IBM Cloud"; exit 1; }
          ibmcloud target -r "$IBM_CLOUD_REGION" -g "$IBM_CLOUD_RESOURCE_GROUP" || { echo "‚ùå Failed to set target"; exit 1; }

          # Ensure project exists and handle soft-deleted state
          # Check if project is soft-deleted BEFORE trying to select it
          PROJECT_STATUS=$(ibmcloud ce project get --name "$PROJECT_NAME" 2>&1 || echo "")
          
          if echo "$PROJECT_STATUS" | grep -q "soft deleted"; then
            echo "‚ö†Ô∏è  Project '$PROJECT_NAME' is soft-deleted, creating new one with timestamp..."
            NEW_PROJECT_NAME="${PROJECT_NAME}-$(date +%s)"
            echo "üÜï Creating project '$NEW_PROJECT_NAME'..."
            ibmcloud ce project create --name "$NEW_PROJECT_NAME" || { echo "‚ùå Failed to create project"; exit 1; }
            ibmcloud ce project select --name "$NEW_PROJECT_NAME" || { echo "‚ùå Failed to select new project"; exit 1; }
            PROJECT_NAME="$NEW_PROJECT_NAME"
            echo "‚úÖ Using new project: $PROJECT_NAME"
          elif ibmcloud ce project get --name "$PROJECT_NAME" &>/dev/null; then
            echo "‚úÖ Project '$PROJECT_NAME' exists - selecting..."
            ibmcloud ce project select --name "$PROJECT_NAME" || { echo "‚ùå Failed to select project"; exit 1; }
          else
            echo "üÜï Creating project '$PROJECT_NAME'..."
            ibmcloud ce project create --name "$PROJECT_NAME" || { echo "‚ùå Failed to create project"; exit 1; }
            ibmcloud ce project select --name "$PROJECT_NAME" || { echo "‚ùå Failed to select project"; exit 1; }
          fi
          
          # Get backend URL if REACT_APP_API_URL is not set
          if [ -z "$REACT_APP_API_URL" ] || [ "$REACT_APP_API_URL" = "" ]; then
            echo "‚ö†Ô∏è  REACT_APP_API_URL not set, getting backend URL from Code Engine..."
            BACKEND_URL_FROM_CE=$(ibmcloud ce app get --name "$BACKEND_APP_NAME" --output json 2>/dev/null | jq -r '.status.url // empty' | head -1)
            if [ -n "$BACKEND_URL_FROM_CE" ] && [ "$BACKEND_URL_FROM_CE" != "null" ] && [ "$BACKEND_URL_FROM_CE" != "" ]; then
              REACT_APP_API_URL="$BACKEND_URL_FROM_CE"
              echo "‚úÖ Using backend URL from Code Engine: $REACT_APP_API_URL"
            else
              echo "‚ö†Ô∏è  Could not get backend URL, using default"
              REACT_APP_API_URL="http://localhost:8000"
            fi
          fi
          
          # Set BACKEND_URL for nginx config (use REACT_APP_API_URL)
          BACKEND_URL="$REACT_APP_API_URL"
          echo "‚úÖ Backend URL for nginx: $BACKEND_URL"

          # Create or update registry access secret (if not already created by backend)
          echo "Setting up registry access..."
          if ibmcloud ce secret get --name icr-secret > /dev/null 2>&1; then
            echo "Registry secret already exists"
          else
            echo "Creating registry access secret..."
            ibmcloud ce secret create --name icr-secret \
              --format registry \
              --server ${ICR_REGION}.icr.io \
              --username iamapikey \
              --password "$IBM_CLOUD_API_KEY"
          fi

          # Deploy or update frontend application (idempotent)
          # Try to update first - if app doesn't exist, update will fail and we'll create
          echo "Checking if frontend application exists..."
          set +e  # Temporarily disable exit on error to check update result
          UPDATE_OUTPUT=$(ibmcloud ce app update --name "$APP_NAME" \
              --image "$IMAGE_URL" \
              --registry-secret icr-secret \
              --min-scale 1 \
              --max-scale 3 \
              --cpu 0.5 \
              --memory 1G \
              --env REACT_APP_API_URL="$REACT_APP_API_URL" \
              --env REACT_APP_WS_URL="$REACT_APP_WS_URL" \
              --env BACKEND_URL="$BACKEND_URL" 2>&1)
          UPDATE_EXIT=$?
          set -e  # Re-enable exit on error
          
          if [ $UPDATE_EXIT -ne 0 ] && echo "$UPDATE_OUTPUT" | grep -qE "not found|does not exist|No.*found"; then
            echo "App not found, creating new frontend application..."
            ibmcloud ce app create --name "$APP_NAME" \
              --image "$IMAGE_URL" \
              --registry-secret icr-secret \
              --min-scale 1 \
              --max-scale 3 \
              --cpu 0.5 \
              --memory 1G \
              --port 3000 \
              --env REACT_APP_API_URL="$REACT_APP_API_URL" \
              --env REACT_APP_WS_URL="$REACT_APP_WS_URL" \
              --env BACKEND_URL="$BACKEND_URL" || { echo "‚ùå Failed to create app"; exit 1; }
            echo "‚úÖ Frontend application created successfully"
          else
            if [ $UPDATE_EXIT -eq 0 ]; then
              echo "‚úÖ Frontend application updated successfully"
            else
              echo "‚ùå Failed to update frontend application"
              echo "Update output: $UPDATE_OUTPUT"
              exit 1
            fi
          fi
          
          # Verify deployment and show revision info
          echo "Verifying frontend deployment..."
          sleep 5  # Give Code Engine a moment to create the revision
          APP_STATUS=$(ibmcloud ce app get --name "$APP_NAME" --output json 2>/dev/null || echo "{}")
          LATEST_REVISION=$(echo "$APP_STATUS" | jq -r '.status.latestCreatedRevisionName // empty')
          if [ -n "$LATEST_REVISION" ] && [ "$LATEST_REVISION" != "null" ]; then
            echo "‚úÖ New revision created: $LATEST_REVISION"
            echo "Image: $IMAGE_URL"
            REVISION_STATUS=$(ibmcloud ce revision get --name "$LATEST_REVISION" --output json 2>/dev/null | jq -r '.status.conditions[]? | select(.type == "Ready") | "Status: \(.status), Reason: \(.reason // "N/A"), Message: \(.message // "N/A")"' || echo "Could not get revision status")
            echo "$REVISION_STATUS"
          else
            echo "‚ö†Ô∏è  Could not determine latest revision - deployment may still be in progress"
          fi

          echo "Frontend deployment complete!"

  smoke-test:
    needs: [deploy-infrastructure, deploy-backend, deploy-frontend]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: read
    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up IBM Cloud CLI
        uses: IBM/actions-ibmcloud-cli@v1
        with:
          api_key: ${{ secrets.IBM_CLOUD_API_KEY }}
          region: ${{ env.IBM_CLOUD_REGION }}
          group: ${{ vars.IBM_CLOUD_RESOURCE_GROUP || 'rag-modulo-deployment' }}
          plugins: code-engine

      - name: Login and select Code Engine project
        env:
          IBM_CLOUD_API_KEY: ${{ secrets.IBM_CLOUD_API_KEY }}
          IBM_CLOUD_REGION: ${{ env.IBM_CLOUD_REGION }}
          IBM_CLOUD_RESOURCE_GROUP: ${{ vars.IBM_CLOUD_RESOURCE_GROUP || 'rag-modulo-deployment' }}
          PROJECT_NAME: ${{ needs.deploy-infrastructure.outputs.project_name || env.PROJECT_NAME }}
        run: |
          set -e
          echo "Logging in to IBM Cloud..."
          ibmcloud login --apikey "$IBM_CLOUD_API_KEY" --no-region || { echo "‚ùå Failed to login"; exit 1; }
          ibmcloud target -r "$IBM_CLOUD_REGION" -g "$IBM_CLOUD_RESOURCE_GROUP" || { echo "‚ùå Failed to set target"; exit 1; }
          
          if [ -z "$PROJECT_NAME" ]; then
            echo "‚ùå PROJECT_NAME is empty"
            exit 1
          fi
          
          echo "Selecting Code Engine project: $PROJECT_NAME"
          ibmcloud ce project select --name "$PROJECT_NAME" || { echo "‚ùå Failed to select project"; exit 1; }

      - name: Check app deployment status
        env:
          BACKEND_APP_NAME: ${{ env.BACKEND_APP_NAME }}
          FRONTEND_APP_NAME: ${{ env.FRONTEND_APP_NAME }}
        run: |
          set -e
          echo "Checking current app deployment status..."
          
          # Check backend status
          if ibmcloud ce app get --name "$BACKEND_APP_NAME" --output json 2>/dev/null | jq -e '.status.conditions[]? | select(.status == "False" and (.reason == "RevisionFailed" or .reason == "ContainerMissing"))' > /dev/null; then
            echo "‚ö†Ô∏è  Backend app is in failed state - this may be due to missing image"
            echo "The deploy job should have updated it with the correct image"
            echo "If this persists, the image verification step may have passed but deployment failed"
          fi
          
          # Check frontend status
          if ibmcloud ce app get --name "$FRONTEND_APP_NAME" --output json 2>/dev/null | jq -e '.status.conditions[]? | select(.status == "False" and (.reason == "RevisionFailed" or .reason == "ContainerMissing"))' > /dev/null; then
            echo "‚ö†Ô∏è  Frontend app is in failed state - this may be due to missing image"
            echo "The deploy job should have updated it with the correct image"
            echo "If this persists, the image verification step may have passed but deployment failed"
          fi

      - name: Wait for apps to be ready
        env:
          BACKEND_APP_NAME: ${{ env.BACKEND_APP_NAME }}
          FRONTEND_APP_NAME: ${{ env.FRONTEND_APP_NAME }}
        run: |
          set -e
          echo "Waiting for apps to be ready..."
          
          # Function to check app status and detect failures
          check_app_status() {
            local APP_NAME=$1
            local APP_JSON=$(ibmcloud ce app get --name "$APP_NAME" --output json 2>/dev/null || echo "{}")
            
            if [ "$APP_JSON" = "{}" ]; then
              echo "WARNING: Could not get app status for $APP_NAME"
              return 1
            fi
            
            # Check for ready revision
            local READY_REVISION=$(echo "$APP_JSON" | jq -r '.status.latestReadyRevisionName // empty')
            if [ -n "$READY_REVISION" ] && [ "$READY_REVISION" != "null" ]; then
              echo "READY:$READY_REVISION"
              return 0
            fi
            
            # Check for failed conditions
            local FAILED_CONDITION=$(echo "$APP_JSON" | jq -r '.status.conditions[]? | select(.status == "False" and (.reason == "RevisionFailed" or .reason == "ContainerMissing" or .reason == "ContainerUnhealthy")) | .message // empty' | head -1)
            if [ -n "$FAILED_CONDITION" ] && [ "$FAILED_CONDITION" != "null" ]; then
              echo "FAILED:$FAILED_CONDITION"
              return 1
            fi
            
            # Check latest revision status
            local LATEST_REVISION=$(echo "$APP_JSON" | jq -r '.status.latestCreatedRevisionName // empty')
            if [ -n "$LATEST_REVISION" ] && [ "$LATEST_REVISION" != "null" ]; then
              local REVISION_STATUS=$(ibmcloud ce revision get --name "$LATEST_REVISION" --output json 2>/dev/null | jq -r '.status.conditions[]? | select(.type == "Ready" and .status == "False") | .message // empty' | head -1)
              if [ -n "$REVISION_STATUS" ] && [ "$REVISION_STATUS" != "null" ]; then
                echo "FAILED:$REVISION_STATUS"
                return 1
              fi
            fi
            
            # Still waiting
            echo "WAITING"
            return 2
          }
          
          # Wait for backend (max 5 minutes)
          echo "Checking backend status..."
          BACKEND_READY=false
          for i in {1..30}; do
            STATUS_RESULT=$(check_app_status "$BACKEND_APP_NAME" || echo "WAITING")
            
            if [[ "$STATUS_RESULT" == READY:* ]]; then
              REVISION=$(echo "$STATUS_RESULT" | cut -d: -f2)
              echo "‚úÖ Backend is ready (revision: $REVISION)"
              BACKEND_READY=true
              break
            elif [[ "$STATUS_RESULT" == FAILED:* ]]; then
              ERROR=$(echo "$STATUS_RESULT" | cut -d: -f2-)
              echo "‚ùå Backend deployment failed: $ERROR"
              echo ""
              echo "Debugging information:"
              ibmcloud ce app get --name "$BACKEND_APP_NAME" --output json | jq '.status.conditions' || true
              echo ""
              echo "Latest revision details:"
              LATEST_REV=$(ibmcloud ce app get --name "$BACKEND_APP_NAME" --output json | jq -r '.status.latestCreatedRevisionName // empty')
              if [ -n "$LATEST_REV" ] && [ "$LATEST_REV" != "null" ]; then
                ibmcloud ce revision get --name "$LATEST_REV" --output json | jq '.status.conditions' || true
              fi
              exit 1
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ùå Backend did not become ready within 5 minutes"
              echo ""
              echo "Current app status:"
              ibmcloud ce app get --name "$BACKEND_APP_NAME" --output json | jq '.status' || true
              exit 1
            fi
            echo "Waiting for backend... ($i/30)"
            sleep 10
          done
          
          # Wait for frontend (max 5 minutes)
          echo "Checking frontend status..."
          FRONTEND_READY=false
          for i in {1..30}; do
            STATUS_RESULT=$(check_app_status "$FRONTEND_APP_NAME" || echo "WAITING")
            
            if [[ "$STATUS_RESULT" == READY:* ]]; then
              REVISION=$(echo "$STATUS_RESULT" | cut -d: -f2)
              echo "‚úÖ Frontend is ready (revision: $REVISION)"
              FRONTEND_READY=true
              break
            elif [[ "$STATUS_RESULT" == FAILED:* ]]; then
              ERROR=$(echo "$STATUS_RESULT" | cut -d: -f2-)
              echo "‚ùå Frontend deployment failed: $ERROR"
              echo ""
              echo "Debugging information:"
              ibmcloud ce app get --name "$FRONTEND_APP_NAME" --output json | jq '.status.conditions' || true
              echo ""
              echo "Latest revision details:"
              LATEST_REV=$(ibmcloud ce app get --name "$FRONTEND_APP_NAME" --output json | jq -r '.status.latestCreatedRevisionName // empty')
              if [ -n "$LATEST_REV" ] && [ "$LATEST_REV" != "null" ]; then
                ibmcloud ce revision get --name "$LATEST_REV" --output json | jq '.status.conditions' || true
              fi
              exit 1
            fi
            
            if [ $i -eq 30 ]; then
              echo "‚ùå Frontend did not become ready within 5 minutes"
              echo ""
              echo "Current app status:"
              ibmcloud ce app get --name "$FRONTEND_APP_NAME" --output json | jq '.status' || true
              exit 1
            fi
            echo "Waiting for frontend... ($i/30)"
            sleep 10
          done

      - name: Test Backend Health
        timeout-minutes: 2
        env:
          BACKEND_APP_NAME: ${{ env.BACKEND_APP_NAME }}
        run: |
          set -e
          echo "Getting backend URL..."
          BACKEND_URL=$(ibmcloud ce app get --name "$BACKEND_APP_NAME" --output json | jq -r '.status.url' | head -1)
          
          if [ -z "$BACKEND_URL" ] || [ "$BACKEND_URL" = "null" ]; then
            echo "‚ùå Could not determine backend URL"
            exit 1
          fi
          
          echo "Testing backend at: $BACKEND_URL/health"
          # Retry health check up to 5 times with exponential backoff
          for i in {1..5}; do
            if curl -f -s --max-time 10 "$BACKEND_URL/health" > /dev/null; then
              echo "‚úÖ Backend health check passed (attempt $i)"
              exit 0
            fi
            if [ $i -lt 5 ]; then
              echo "‚ö†Ô∏è  Health check failed, retrying in $((i*2)) seconds... (attempt $i/5)"
              sleep $((i*2))
            fi
          done
          
          echo "‚ùå Backend health check failed after 5 attempts"
          exit 1

      - name: Test Frontend Health
        timeout-minutes: 2
        env:
          FRONTEND_APP_NAME: ${{ env.FRONTEND_APP_NAME }}
        run: |
          set -e
          echo "Getting frontend URL..."
          FRONTEND_URL=$(ibmcloud ce app get --name "$FRONTEND_APP_NAME" --output json | jq -r '.status.url' | head -1)
          
          if [ -z "$FRONTEND_URL" ] || [ "$FRONTEND_URL" = "null" ]; then
            echo "‚ùå Could not determine frontend URL"
            exit 1
          fi
          
          echo "Testing frontend at: $FRONTEND_URL"
          # Retry health check up to 5 times with exponential backoff
          for i in {1..5}; do
            if curl -f -s --max-time 10 "$FRONTEND_URL" > /dev/null; then
              echo "‚úÖ Frontend health check passed (attempt $i)"
              exit 0
            fi
            if [ $i -lt 5 ]; then
              echo "‚ö†Ô∏è  Health check failed, retrying in $((i*2)) seconds... (attempt $i/5)"
              sleep $((i*2))
            fi
          done
          
          echo "‚ùå Frontend health check failed after 5 attempts"
          exit 1

      - name: Test Application Integration
        timeout-minutes: 1
        env:
          BACKEND_APP_NAME: ${{ env.BACKEND_APP_NAME }}
          FRONTEND_APP_NAME: ${{ env.FRONTEND_APP_NAME }}
        run: |
          set -e
          BACKEND_URL=$(ibmcloud ce app get --name "$BACKEND_APP_NAME" --output json | jq -r '.status.url' | head -1)
          FRONTEND_URL=$(ibmcloud ce app get --name "$FRONTEND_APP_NAME" --output json | jq -r '.status.url' | head -1)
          
          echo "‚úÖ Complete application deployed successfully!"
          echo "Backend URL: $BACKEND_URL"
          echo "Frontend URL: $FRONTEND_URL"
          echo "Application is ready for use!"

  # Cleanup old images from registry to manage storage
  cleanup-old-images:
    needs: [build-and-push-backend, build-and-push-frontend]
    if: always() && (github.event_name == 'schedule' || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
    steps:
      - name: Check out code
        uses: actions/checkout@v5

      - name: Set up IBM Cloud CLI
        uses: IBM/actions-ibmcloud-cli@v1
        with:
          api_key: ${{ secrets.IBM_CLOUD_API_KEY }}
          region: ${{ env.IBM_CLOUD_REGION }}
          group: ${{ vars.IBM_CLOUD_RESOURCE_GROUP || 'rag-modulo-deployment' }}
          plugins: container-registry

      - name: Clean up old backend images
        env:
          ICR_REGION: ${{ env.ICR_REGION }}
          CR_NAMESPACE: ${{ env.CR_NAMESPACE }}
          BACKEND_APP_NAME: ${{ env.BACKEND_APP_NAME }}
          IMAGE_RETENTION_COUNT: ${{ env.IMAGE_RETENTION_COUNT }}
        run: |
          set -e
          echo "Cleaning up old backend images (keeping last $IMAGE_RETENTION_COUNT)..."
          
          # Login to ICR
          ibmcloud cr login || { echo "‚ùå Failed to login to ICR"; exit 1; }
          
          # Get list of images, sorted by creation date (newest first)
          # Keep only commit SHA tags (not latest, not version tags)
          IMAGES=$(ibmcloud cr images --format json "$CR_NAMESPACE/$BACKEND_APP_NAME" 2>/dev/null | \
            jq -r --arg retention "$IMAGE_RETENTION_COUNT" '
              [.[] | select(.RepoTags[]? | test("^[0-9a-f]{40}$"))] |
              sort_by(.Created) | reverse |
              .[($retention | tonumber):] |
              .[].RepoTags[]? | select(test("^[0-9a-f]{40}$"))
            ' || echo "")
          
          if [ -z "$IMAGES" ]; then
            echo "‚úÖ No old images to clean up"
            exit 0
          fi
          
          echo "Found images to delete:"
          echo "$IMAGES" | head -10
          
          # Delete old images (keep version tags and latest)
          echo "$IMAGES" | while read -r tag; do
            if [ -n "$tag" ]; then
              echo "Deleting: $CR_NAMESPACE/$BACKEND_APP_NAME:$tag"
              ibmcloud cr image-rm "$CR_NAMESPACE/$BACKEND_APP_NAME:$tag" --force || true
            fi
          done
          
          echo "‚úÖ Backend image cleanup complete"

      - name: Clean up old frontend images
        env:
          ICR_REGION: ${{ env.ICR_REGION }}
          CR_NAMESPACE: ${{ env.CR_NAMESPACE }}
          FRONTEND_APP_NAME: ${{ env.FRONTEND_APP_NAME }}
          IMAGE_RETENTION_COUNT: ${{ env.IMAGE_RETENTION_COUNT }}
        run: |
          set -e
          echo "Cleaning up old frontend images (keeping last $IMAGE_RETENTION_COUNT)..."
          
          # Login to ICR
          ibmcloud cr login || { echo "‚ùå Failed to login to ICR"; exit 1; }
          
          # Get list of images, sorted by creation date (newest first)
          # Keep only commit SHA tags (not latest, not version tags)
          IMAGES=$(ibmcloud cr images --format json "$CR_NAMESPACE/$FRONTEND_APP_NAME" 2>/dev/null | \
            jq -r --arg retention "$IMAGE_RETENTION_COUNT" '
              [.[] | select(.RepoTags[]? | test("^[0-9a-f]{40}$"))] |
              sort_by(.Created) | reverse |
              .[($retention | tonumber):] |
              .[].RepoTags[]? | select(test("^[0-9a-f]{40}$"))
            ' || echo "")
          
          if [ -z "$IMAGES" ]; then
            echo "‚úÖ No old images to clean up"
            exit 0
          fi
          
          echo "Found images to delete:"
          echo "$IMAGES" | head -10
          
          # Delete old images (keep version tags and latest)
          echo "$IMAGES" | while read -r tag; do
            if [ -n "$tag" ]; then
              echo "Deleting: $CR_NAMESPACE/$FRONTEND_APP_NAME:$tag"
              ibmcloud cr image-rm "$CR_NAMESPACE/$FRONTEND_APP_NAME:$tag" --force || true
            fi
          done
          
          echo "‚úÖ Frontend image cleanup complete"
