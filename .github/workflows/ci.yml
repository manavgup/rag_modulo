name: CI/CD Pipeline

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

env:
  # Use GHCR images by default
  BACKEND_IMAGE: ghcr.io/manavgup/rag_modulo/backend:latest
  FRONTEND_IMAGE: ghcr.io/manavgup/rag_modulo/frontend:latest
  TEST_IMAGE: ghcr.io/manavgup/rag_modulo/backend:latest

jobs:
  # Fast feedback - lint and unit tests without infrastructure  
  lint-and-unit:
    runs-on: ubuntu-latest
    env:
      # Required environment variables for tests
      JWT_SECRET_KEY: test-secret-key-for-ci
      RAG_LLM: openai
      WATSONX_INSTANCE_ID: test-instance-id
      WATSONX_APIKEY: test-api-key
      WATSONX_URL: https://test.watsonx.com
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'
          
      - name: Cache Poetry dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pypoetry
            backend/.venv
          key: ${{ runner.os }}-poetry-${{ hashFiles('backend/poetry.lock') }}
          restore-keys: |
            ${{ runner.os }}-poetry-
          
      - name: Install dependencies
        run: |
          cd backend
          # Create .env file with test values for CI
          cat > .env << EOF
          JWT_SECRET_KEY=test-secret-key-for-ci
          RAG_LLM=openai
          WATSONX_INSTANCE_ID=test-instance-id
          WATSONX_APIKEY=test-api-key
          WATSONX_URL=https://test.watsonx.com
          COLLECTIONDB_NAME=test_db
          COLLECTIONDB_USER=test_user
          COLLECTIONDB_PASS=test_pass
          MINIO_ROOT_USER=minioadmin
          MINIO_ROOT_PASSWORD=minioadmin
          EOF
          
          pip install poetry
          poetry config virtualenvs.in-project true
          # Regenerate lock file to ensure sync
          poetry lock
          # Install main, dev, and test groups for CI
          poetry install --with dev,test
          
      - name: Check formatting
        run: make format-check
        continue-on-error: true  # Don't fail on format issues initially
        
      - name: Run linting (Ruff + MyPy)
        run: make lint
        continue-on-error: true  # Don't fail on lint issues initially

      - name: Run security checks
        run: make security-check
        continue-on-error: true  # Don't fail on security issues initially
          
      - name: Run unit tests with coverage
        run: make coverage
        continue-on-error: true  # Don't fail on coverage threshold initially

  # Build images once
  build:
    runs-on: ubuntu-latest
    outputs:
      backend-image: ${{ steps.build.outputs.backend-image }}
      frontend-image: ${{ steps.build.outputs.frontend-image }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        
      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-
            
      - name: Build images
        id: build
        run: |
          # Build with commit SHA for uniqueness
          BACKEND_TAG="ghcr.io/manavgup/rag_modulo/backend:${{ github.sha }}"
          FRONTEND_TAG="ghcr.io/manavgup/rag_modulo/frontend:${{ github.sha }}"
          
          docker build -t $BACKEND_TAG -f ./backend/Dockerfile.backend ./backend
          docker build -t $FRONTEND_TAG -f ./webui/Dockerfile.frontend ./webui
          
          # Also tag as latest for compose compatibility
          docker tag $BACKEND_TAG ghcr.io/manavgup/rag_modulo/backend:latest
          docker tag $FRONTEND_TAG ghcr.io/manavgup/rag_modulo/frontend:latest
          
          echo "backend-image=$BACKEND_TAG" >> $GITHUB_OUTPUT
          echo "frontend-image=$FRONTEND_TAG" >> $GITHUB_OUTPUT

  # Integration tests (only when needed)
  integration-test:
    needs: [build, lint-and-unit]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        vector_db: [milvus]
      fail-fast: false
    
    env:
      VECTOR_DB: ${{ matrix.vector_db }}
      BACKEND_IMAGE: ${{ needs.build.outputs.backend-image }}
      FRONTEND_IMAGE: ${{ needs.build.outputs.frontend-image }}
      
    steps:
      - uses: actions/checkout@v4
      
      - name: Create environment and volume directories
        run: |
          # Use the .env.ci file for CI testing
          cp .env.ci .env
          
          make create-volumes
          
      - name: Start minimal services for integration tests
        run: |
          echo "Starting essential services for integration tests..."
          # Only start essential services to speed up tests
          docker compose up -d postgres milvus-etcd milvus-standalone
          echo "Services started, waiting briefly..."
          sleep 30
          docker compose ps
        env:
          DOCKER_BUILDKIT: 1
          
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Run integration tests (lightweight)
        run: |
          echo "Running integration tests with built images..."
          make create-test-dirs
          # Run only integration tests, skip performance tests for speed
          docker compose run --rm \
            -e TESTING=true \
            -e CONTAINER_ENV=false \
            test pytest -v -s -m "integration and not performance" \
            --maxfail=3 \
            --tb=short \
            || echo "Some integration tests failed (non-blocking for now)"
        
      - name: Upload test reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-reports-${{ matrix.vector_db }}
          path: test-reports/
          retention-days: 1

  # Simple reporting without complex XML parsing
  report:
    needs: [lint-and-unit, build, integration-test]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Report results
        run: |
          echo "## CI/CD Results" 
          echo "- Lint and Unit Tests: ${{ needs.lint-and-unit.result }}"
          echo "- Build: ${{ needs.build.result }}"
          echo "- Integration Tests: ${{ needs.integration-test.result }}"
          
          if [[ "${{ needs.lint-and-unit.result }}" == "failure" || "${{ needs.build.result }}" == "failure" ]]; then
            echo "❌ Critical jobs failed"
            exit 1
          else
            echo "✅ Core jobs passed"
          fi