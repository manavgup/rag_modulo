"""TDD Red Phase: Unit tests for conversation functionality.

DISABLED - These tests require proper mocking for TDD approach.
Use test_conversation_service_simple.py for basic unit tests.

Unit tests focus on individual methods and classes in isolation,
with mocked dependencies.
"""

from datetime import datetime
from unittest.mock import Mock
from uuid import uuid4

import pytest

from rag_solution.core.exceptions import NotFoundError, SessionExpiredError, ValidationError
from rag_solution.schemas.conversation_schema import (
    ConversationContext,
    ConversationMessageInput,
    ConversationMessageOutput,
    ConversationSessionInput,
    ConversationSessionOutput,
    MessageRole,
    MessageType,
    SessionStatus,
)
from rag_solution.services.conversation_service import ConversationService
from rag_solution.services.question_service import QuestionService


class TestConversationServiceUnitTDD:
    """Unit tests for ConversationService individual methods."""

    @pytest.fixture
    def mock_db(self) -> Mock:
        """Mock database session."""
        return Mock()

    @pytest.fixture
    def mock_settings(self) -> Mock:
        """Mock settings."""
        settings = Mock()
        settings.session_timeout_minutes = 30
        settings.max_context_window_size = 8000
        settings.max_messages_per_session = 100
        return settings

    @pytest.fixture
    def conversation_service(self, mock_db: Mock, mock_settings: Mock) -> ConversationService:
        """Create conversation service instance."""
        return ConversationService(mock_db, mock_settings)

    # ==================== UNIT TESTS ====================

    @pytest.mark.unit
    async def test_create_session_validation_success(self, conversation_service: ConversationService) -> None:
        """Unit: Test create_session validates input successfully."""
        # Arrange
        session_input = ConversationSessionInput(user_id=uuid4(), collection_id=uuid4(), session_name="Test Session")

        # Act
        result = await conversation_service.create_session(session_input)

        # Assert
        assert isinstance(result, ConversationSessionOutput)
        assert result.session_name == "Test Session"
        assert result.status == SessionStatus.ACTIVE

    @pytest.mark.unit
    async def test_create_session_validation_error(self, conversation_service: ConversationService) -> None:
        """Unit: Test create_session raises ValidationError for invalid input."""
        # Arrange
        session_input = ConversationSessionInput(
            user_id=uuid4(),
            collection_id=uuid4(),
            session_name="",  # Invalid empty name
        )

        # Act & Assert
        with pytest.raises(ValidationError):
            conversation_service.create_session(session_input)

    @pytest.mark.unit
    async def test_get_session_success(self, conversation_service: ConversationService) -> None:
        """Unit: Test get_session returns session when found."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()

        # Act
        result = await conversation_service.get_session(session_id, user_id)

        # Assert
        assert isinstance(result, ConversationSessionOutput)
        assert result.id == session_id
        assert result.user_id == user_id

    @pytest.mark.unit
    async def test_get_session_not_found(self, conversation_service: ConversationService) -> None:
        """Unit: Test get_session raises NotFoundError when session not found."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()

        # Act & Assert
        with pytest.raises(NotFoundError):
            await conversation_service.get_session(session_id, user_id)

    @pytest.mark.unit
    async def test_add_message_validation_success(self, conversation_service: ConversationService) -> None:
        """Unit: Test add_message validates input successfully."""
        # Arrange
        message_input = ConversationMessageInput(
            session_id=uuid4(), content="Test message", role=MessageRole.USER, message_type=MessageType.QUESTION
        )

        # Act
        result = await conversation_service.add_message(message_input)

        # Assert
        assert isinstance(result, ConversationMessageOutput)
        assert result.content == "Test message"
        assert result.role == MessageRole.USER

    @pytest.mark.unit
    async def test_add_message_session_not_found(self, conversation_service: ConversationService) -> None:
        """Unit: Test add_message raises NotFoundError for non-existent session."""
        # Arrange
        message_input = ConversationMessageInput(
            session_id=uuid4(), content="Test message", role=MessageRole.USER, message_type=MessageType.QUESTION
        )

        # Act & Assert
        with pytest.raises(NotFoundError):
            await conversation_service.add_message(message_input)

    @pytest.mark.unit
    async def test_add_message_session_expired(self, conversation_service: ConversationService) -> None:
        """Unit: Test add_message raises SessionExpiredError for expired session."""
        # Arrange
        message_input = ConversationMessageInput(
            session_id=uuid4(), content="Test message", role=MessageRole.USER, message_type=MessageType.QUESTION
        )

        # Act & Assert
        with pytest.raises(SessionExpiredError):
            await conversation_service.add_message(message_input)

    @pytest.mark.unit
    async def test_update_session_success(self, conversation_service: ConversationService) -> None:
        """Unit: Test update_session updates session successfully."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()
        updates = {"session_name": "Updated Name"}

        # Act
        result = await conversation_service.update_session(session_id, user_id, updates)

        # Assert
        assert isinstance(result, ConversationSessionOutput)
        assert result.session_name == "Updated Name"

    @pytest.mark.unit
    async def test_update_session_not_found(self, conversation_service: ConversationService) -> None:
        """Unit: Test update_session raises NotFoundError for non-existent session."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()
        updates = {"session_name": "Updated Name"}

        # Act & Assert
        with pytest.raises(NotFoundError):
            await conversation_service.update_session(session_id, user_id, updates)

    @pytest.mark.unit
    async def test_delete_session_success(self, conversation_service: ConversationService) -> None:
        """Unit: Test delete_session deletes session successfully."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()

        # Act
        result = await conversation_service.delete_session(session_id, user_id)

        # Assert
        assert result is True

    @pytest.mark.unit
    async def test_delete_session_not_found(self, conversation_service: ConversationService) -> None:
        """Unit: Test delete_session raises NotFoundError for non-existent session."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()

        # Act & Assert
        with pytest.raises(NotFoundError):
            await conversation_service.delete_session(session_id, user_id)

    @pytest.mark.unit
    async def test_get_session_messages_pagination(self, conversation_service: ConversationService) -> None:
        """Unit: Test get_session_messages with pagination parameters."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()
        limit = 10
        offset = 5

        # Act
        result = conversation_service.get_session_messages(session_id, user_id, limit, offset)

        # Assert
        assert isinstance(result, list)
        assert len(result) <= limit

    @pytest.mark.unit
    async def test_archive_session_success(self, conversation_service: ConversationService) -> None:
        """Unit: Test archive_session changes status to ARCHIVED."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()

        # Act
        result = conversation_service.archive_session(session_id, user_id)

        # Assert
        assert isinstance(result, ConversationSessionOutput)
        assert result.status == SessionStatus.ARCHIVED

    @pytest.mark.unit
    async def test_restore_session_success(self, conversation_service: ConversationService) -> None:
        """Unit: Test restore_session changes status to ACTIVE."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()

        # Act
        result = conversation_service.restore_session(session_id, user_id)

        # Assert
        assert isinstance(result, ConversationSessionOutput)
        assert result.status == SessionStatus.ACTIVE

    @pytest.mark.unit
    async def test_export_session_json_format(self, conversation_service: ConversationService) -> None:
        """Unit: Test export_session with JSON format."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()
        export_format = "json"

        # Act
        result = await conversation_service.export_session(session_id, user_id, export_format)

        # Assert
        assert isinstance(result, dict)
        assert "session_data" in result
        assert "messages" in result

    @pytest.mark.unit
    async def test_export_session_unsupported_format(self, conversation_service: ConversationService) -> None:
        """Unit: Test export_session raises ValidationError for unsupported format."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()
        export_format = "unsupported"

        # Act & Assert
        with pytest.raises(ValidationError):
            await conversation_service.export_session(session_id, user_id, export_format)

    @pytest.mark.unit
    async def test_cleanup_expired_sessions(self, conversation_service: ConversationService) -> None:
        """Unit: Test cleanup_expired_sessions returns count of cleaned sessions."""
        # Act
        result = conversation_service.cleanup_expired_sessions()

        # Assert
        assert isinstance(result, int)
        assert result >= 0

    @pytest.mark.unit
    async def test_get_session_statistics(self, conversation_service: ConversationService) -> None:
        """Unit: Test get_session_statistics returns correct structure."""
        # Arrange
        session_id = uuid4()
        user_id = uuid4()

        # Act
        result = await conversation_service.get_session_statistics(session_id, user_id)

        # Assert
        assert isinstance(result, dict)
        assert "message_count" in result
        assert "session_duration" in result
        assert "average_response_time" in result

    @pytest.mark.unit
    async def test_search_sessions_by_query(self, conversation_service: ConversationService) -> None:
        """Unit: Test search_sessions returns filtered results."""
        # Arrange
        user_id = uuid4()
        query = "machine learning"

        # Act
        result = conversation_service.search_sessions(user_id, query)

        # Assert
        assert isinstance(result, list)
        assert all(isinstance(session, ConversationSessionOutput) for session in result)

    @pytest.mark.unit
    async def test_get_user_sessions_with_status_filter(self, conversation_service: ConversationService) -> None:
        """Unit: Test get_user_sessions with status filter."""
        # Arrange
        user_id = uuid4()
        status = SessionStatus.ACTIVE

        # Act
        result = conversation_service.get_user_sessions(user_id, status=status)

        # Assert
        assert isinstance(result, list)
        assert all(session.status == status for session in result)
